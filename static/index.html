<!doctype html>
<html lang="zh-Hans">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Void Halo | JMComic ä¸‹è½½å™¨</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: radial-gradient(circle at 20% 20%, rgba(82, 125, 255, .25), transparent 30%),
        radial-gradient(circle at 80% 10%, rgba(255, 115, 168, .28), transparent 28%),
        radial-gradient(circle at 40% 80%, rgba(115, 255, 186, .25), transparent 30%),
        #0b0c10;
      --card: rgba(19, 21, 28, 0.9);
      --muted: #9aa0b5;
      --accent: #68d2ff;
      --accent-2: #f75d9b;
      --text: #f8f9fb;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      overflow-x: hidden;
    }

    body {
      margin: 0;
      font-family: 'Space Grotesk', 'Segoe UI', system-ui, -apple-system, sans-serif;
      color: var(--text);
      background: var(--bg);
      min-height: 100vh;
      padding: 16px;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }

    .shell {
      width: 100%;
      max-width: 1100px;
      display: grid;
      gap: 16px;
      grid-template-columns: 1.1fr 0.9fr;
    }

    @media (max-width: 900px) {
      .shell {
        grid-template-columns: 1fr;
        gap: 12px;
      }

      body {
        padding: 8px;
        align-items: flex-start;
      }
    }

    @media (max-width: 480px) {
      body {
        padding: 6px;
      }

      .card {
        padding: 14px 12px;
        border-radius: 12px;
      }
    }

    .card {
      background: var(--card);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      padding: 20px 22px;
      backdrop-filter: blur(10px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
      min-width: 0;
      /* Prevent grid blowout from long content */
      overflow: hidden;
      /* Clip any overflowing content */
    }

    h1 {
      margin: 0 0 4px;
      font-size: 28px;
      letter-spacing: 0.5px;
    }

    p.sub {
      margin: 0;
      color: var(--muted);
    }

    form {
      margin-top: 14px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    input[type="text"],
    input[type="password"] {
      flex: 1 1 220px;
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.04);
      color: #fff;
      font-size: 16px;
      outline: none;
    }

    input[type="text"]:focus,
    input[type="password"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(104, 210, 255, 0.25);
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 12px 16px;
      font-size: 15px;
      cursor: pointer;
      color: #0b0c10;
      background: linear-gradient(135deg, var(--accent), #8df2ff);
      font-weight: 600;
      min-width: 120px;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 20px rgba(104, 210, 255, 0.3);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      color: var(--muted);
      font-size: 13px;
    }

    .metric-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .metric {
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.05);
      min-width: 140px;
    }

    .label {
      color: var(--muted);
      font-size: 13px;
    }

    .value {
      font-size: 16px;
      font-weight: 600;
    }

    .progress {
      position: relative;
      width: 100%;
      height: 16px;
      margin: 16px 0 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      overflow: hidden;
    }

    .bar {
      position: absolute;
      inset: 0;
      width: 0;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      transition: width 160ms ease;
    }

    .log-box {
      max-height: 360px;
      overflow: auto;
      padding: 10px 0 4px;
      margin: 0;
      list-style: none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
    }

    .log-box li {
      padding: 6px 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
      color: #d5d9e6;
    }

    .log-box li:nth-child(odd) {
      background: rgba(255, 255, 255, 0.02);
    }

    .muted {
      color: var(--muted);
    }

    .actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    a.btn-link {
      text-decoration: none;
      color: #0b0c10;
      background: linear-gradient(135deg, #8bf8c1, #5ed9ff);
      padding: 12px 14px;
      border-radius: 10px;
      font-weight: 700;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 6px;
    }

    .status-running {
      background: #5ed9ff;
    }

    .status-ready {
      background: #71f09d;
    }

    .status-failed {
      background: #ff6b6b;
    }

    .tree-box {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.07);
      background: rgba(255, 255, 255, 0.03);
    }

    .tree-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .tree-meta {
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 60%;
      text-align: right;
    }

    .tree-output {
      margin: 8px 0 0;
      white-space: pre;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      max-height: 180px;
      overflow: auto;
      color: #d5d9e6;
      background: rgba(0, 0, 0, 0.18);
      border-radius: 8px;
      padding: 10px;
    }

    /* Tab styles */
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 16px;
      background: rgba(255, 255, 255, 0.04);
      border-radius: 12px;
      padding: 4px;
    }

    .tab {
      flex: 1;
      padding: 10px 16px;
      border: none;
      background: transparent;
      color: var(--muted);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 8px;
      transition: all 150ms ease;
    }

    .tab:hover {
      color: var(--text);
    }

    .tab.active {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Album list (todo-list style) */
    .album-list {
      list-style: none;
      margin: 12px 0 0;
      padding: 0;
      max-height: 300px;
      overflow-y: auto;
      overflow-x: hidden;
      min-width: 0;
      /* Prevent content from pushing container */
    }

    .album-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 8px;
      margin-bottom: 6px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      transition: all 150ms ease;
    }

    .album-item.downloading {
      background: rgba(104, 210, 255, 0.1);
      border-color: rgba(104, 210, 255, 0.3);
    }

    .album-item.completed {
      background: rgba(113, 240, 157, 0.1);
      border-color: rgba(113, 240, 157, 0.3);
    }

    .album-item.failed {
      background: rgba(255, 107, 107, 0.1);
      border-color: rgba(255, 107, 107, 0.3);
    }

    .album-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }

    .album-info {
      flex: 1;
      min-width: 0;
    }

    .album-title {
      font-size: 14px;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .album-id {
      font-size: 12px;
      color: var(--muted);
    }

    .album-progress {
      width: 60px;
      text-align: right;
      font-size: 13px;
      color: var(--muted);
    }

    .mini-bar {
      width: 80px;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      overflow: hidden;
    }

    .mini-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      transition: width 150ms ease;
    }

    .retry-btn {
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 4px;
      background: rgba(255, 165, 0, 0.2);
      color: #ffa500;
      border: 1px solid rgba(255, 165, 0, 0.3);
      cursor: pointer;
      white-space: nowrap;
    }

    .retry-btn:hover {
      background: rgba(255, 165, 0, 0.3);
    }

    .retry-btn:disabled {
      opacity: 0.5;
      cursor: wait;
    }

    .album-error {
      font-size: 11px;
      color: #ff6b6b;
      margin-top: 2px;
      word-break: break-all;
      max-width: 200px;
    }

    /* Batch stats */
    .batch-stats {
      display: flex;
      gap: 12px;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .batch-stat {
      padding: 8px 14px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      font-size: 13px;
    }

    .batch-stat strong {
      color: var(--accent);
    }

    /* Mobile responsive improvements */
    @media (max-width: 600px) {
      form {
        flex-direction: column;
      }

      input[type="text"],
      input[type="password"] {
        flex: 1 1 100%;
        min-width: 0;
      }

      button {
        width: 100%;
        min-width: unset;
        padding: 14px 16px;
      }

      h1 {
        font-size: 22px;
      }

      p.sub {
        font-size: 13px;
      }

      .metric {
        min-width: 0;
        flex: 1 1 45%;
      }

      .log-box {
        max-height: 260px;
        font-size: 11px;
      }

      .log-box li {
        padding: 5px 8px;
        word-break: break-all;
      }

      .tree-output {
        max-height: 140px;
        font-size: 10px;
      }

      .album-title {
        white-space: normal;
        word-break: break-word;
        line-height: 1.3;
      }

      .album-item {
        flex-wrap: wrap;
        gap: 6px;
      }

      .album-progress,
      .mini-bar {
        width: auto;
        flex-shrink: 0;
      }

      .actions {
        flex-direction: column;
      }

      .actions button,
      .actions a {
        width: 100%;
        text-align: center;
      }

      .tabs {
        flex-direction: column;
      }

      .tab {
        padding: 12px;
      }
    }

    /* Ensure long text doesn't overflow */
    .value {
      word-break: break-word;
    }

    .tree-meta {
      max-width: 50%;
    }
  </style>
</head>

<body>
  <div class="shell">
    <section class="card">
      <h1>Void Halo</h1>
      <p class="sub">ç”¨ FastAPI + JMComic ä¸‹è½½å™¨ï¼Œå®æ—¶æ—¥å¿— & è¿›åº¦å›ä¼ </p>

      <!-- Tabs -->
      <div class="tabs">
        <button class="tab active" data-tab="single">å•æœ¬ä¸‹è½½</button>
        <button class="tab" data-tab="batch">æ‰¹é‡æ”¶è—ä¸‹è½½</button>
      </div>

      <!-- Single Download Tab -->
      <div id="tab-single" class="tab-content active">
        <form id="job-form">
          <input type="text" name="album_id" placeholder="è¾“å…¥æ¼«ç”» IDï¼Œä¾‹å¦‚ 438696" required />
          <button type="submit" id="start-btn">å¼€å§‹ä¸‹è½½</button>
        </form>

        <div class="metric-row">
          <div class="metric">
            <div class="label">ä»»åŠ¡ ID</div>
            <div class="value" id="job-id">-</div>
          </div>
          <div class="metric">
            <div class="label">æ¼«ç”»å</div>
            <div class="value" id="job-title">-</div>
          </div>
          <div class="metric">
            <div class="label">çŠ¶æ€</div>
            <div class="value"><span class="status-dot" id="status-dot"></span><span id="job-status">å¾…å¼€å§‹</span></div>
          </div>
        </div>

        <div class="progress" aria-label="è¿›åº¦">
          <div class="bar" id="bar"></div>
        </div>
        <div class="label" id="progress-text">0%</div>

        <div class="actions" style="margin-top:12px;">
          <a id="download-link" class="btn-link" href="#" style="display:none;">ä¸‹è½½ Zip</a>
          <button type="button" id="delete-btn"
            style="background:rgba(255,255,255,0.08); color:#fff; border:1px solid rgba(255,255,255,0.12);">åˆ é™¤æ–‡ä»¶</button>
        </div>
      </div>

      <!-- Batch Download Tab -->
      <div id="tab-batch" class="tab-content">
        <form id="batch-form">
          <input type="text" name="username" placeholder="JMComic ç”¨æˆ·å" required />
          <input type="password" name="password" placeholder="å¯†ç " required />
          <button type="submit" id="batch-start-btn">å¼€å§‹æ‰¹é‡ä¸‹è½½</button>
        </form>

        <div class="batch-stats" id="batch-stats" style="display:none;">
          <div class="batch-stat">çŠ¶æ€: <strong id="batch-status">å‡†å¤‡ä¸­</strong></div>
          <div class="batch-stat">è¿›åº¦: <strong id="batch-completed">0</strong> / <strong id="batch-total">0</strong>
          </div>
        </div>

        <div class="progress" aria-label="æ€»è¿›åº¦" id="batch-progress-container" style="display:none;">
          <div class="bar" id="batch-bar"></div>
        </div>
        <div class="label" id="batch-progress-text" style="display:none;">0%</div>

        <ul class="album-list" id="album-list"></ul>

        <div class="actions" style="margin-top:12px;">
          <a id="batch-download-link" class="btn-link" href="#" style="display:none;">ä¸‹è½½å…¨éƒ¨ Zip</a>
          <button type="button" id="batch-cancel-btn"
            style="display:none; background:rgba(255,107,107,0.2); color:#ff6b6b; border:1px solid rgba(255,107,107,0.3);">å–æ¶ˆä¸‹è½½</button>
          <button type="button" id="batch-delete-btn"
            style="display:none; background:rgba(255,255,255,0.08); color:#fff; border:1px solid rgba(255,255,255,0.12);">åˆ é™¤æ–‡ä»¶</button>
        </div>
      </div>
    </section>

    <section class="card" style="min-height:380px;">
      <div class="pill">å®æ—¶æ—¥å¿— / ç›®å½•äº‹ä»¶</div>
      <ul class="log-box" id="logs"></ul>
      <div class="tree-box">
        <div class="tree-head">
          <span class="pill">æš‚å­˜ç›®å½•</span>
          <span class="tree-meta" id="tree-meta">ç­‰å¾…ä»»åŠ¡</span>
        </div>
        <pre class="tree-output" id="tree-output">æœªåŠ è½½</pre>
      </div>
      <div style="margin-top:8px;">
        <button type="button" id="cleanup-btn"
          style="background:rgba(255,107,107,0.15); color:#ff6b6b; border:1px solid rgba(255,107,107,0.25);">ğŸ—‘ï¸
          æ¸…ç†æ‰€æœ‰æ•°æ®</button>
        <span class="label muted" style="margin-left:8px;">æœåŠ¡å™¨é‡å¯ä¼šè‡ªåŠ¨æ¸…ç†æš‚å­˜ç›®å½•</span>
      </div>
    </section>
  </div>

  <script>
    (() => {
      // ==== Tab switching ====
      const tabs = document.querySelectorAll('.tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
        });
      });

      // ==== Single Download ====
      const singleState = {
        jobId: null,
        ws: null,
        autoScroll: true,
        treeTimer: null,
        wsAttempts: 0,
        reconnectTimer: null,
        pollTimer: null,
        lastPolledStatus: null
      };
      const $ = (id) => document.getElementById(id);
      const bar = $('bar');
      const progressText = $('progress-text');
      const statusDot = $('status-dot');
      const jobStatus = $('job-status');
      const jobTitle = $('job-title');
      const jobIdEl = $('job-id');
      const logsEl = $('logs');
      const downloadLink = $('download-link');
      const deleteBtn = $('delete-btn');
      const treeOutput = $('tree-output');
      const treeMeta = $('tree-meta');
      const wsIndicator = $('ws-indicator');
      const wsDot = $('ws-dot');
      const wsLabel = $('ws-label');

      const WS_RETRY_LIMIT = 3;
      const WS_RETRY_DELAY = 1500;
      const POLL_INTERVAL = 3500;

      function setWsIndicator(state, scope = '') {
        const labels = {
          connecting: 'WS è¿æ¥ä¸­',
          connected: 'WS å·²è¿æ¥',
          reconnecting: 'WS é‡è¿ä¸­',
          polling: 'WS è½®è¯¢ä¸­',
          offline: 'WS æœªè¿æ¥'
        };
        wsDot.className = `ws-dot ${state}`;
        const detail = scope ? ` Â· ${scope}` : '';
        wsLabel.textContent = (labels[state] || state) + detail;
      }

      function setStatus(status, message) {
        jobStatus.textContent = message || status;
        statusDot.className = 'status-dot ' + (status === 'completed' ? 'status-ready' : status === 'failed' ? 'status-failed' : 'status-running');
      }

      function setProgress(value) {
        const pct = Math.max(0, Math.min(1, value || 0));
        bar.style.width = `${(pct * 100).toFixed(1)}%`;
        progressText.textContent = `${(pct * 100).toFixed(1)}%`;
      }

      function addLog(msg) {
        const li = document.createElement('li');
        li.textContent = msg;
        logsEl.appendChild(li);
        if (singleState.autoScroll) {
          logsEl.scrollTop = logsEl.scrollHeight;
        }
      }

      function renderTree(lines, root, generatedAt) {
        const content = Array.isArray(lines) && lines.length ? lines.join('\n') : '(ç©ºç›®å½•)';
        treeOutput.textContent = content;
        const ts = generatedAt ? new Date(generatedAt).toLocaleTimeString() : '';
        if (root && ts) {
          treeMeta.textContent = `${root} Â· ${ts}`;
        } else if (ts) {
          treeMeta.textContent = ts;
        } else {
          treeMeta.textContent = 'å·²åˆ·æ–°';
        }
      }

      async function fetchTree() {
        if (!singleState.jobId) return;
        try {
          const res = await fetch(`/api/jobs/${singleState.jobId}/tree`);
          if (res.status === 404) {
            treeOutput.textContent = 'ç›®å½•å·²æ¸…ç†';
            treeMeta.textContent = 'ä»»åŠ¡ä¸å­˜åœ¨æˆ–å·²åˆ é™¤';
            stopTreePolling(false);
            return;
          }
          if (!res.ok) throw new Error('failed');
          const data = await res.json();
          renderTree(data.tree, data.root, data.generated_at);
        } catch (err) {
          treeOutput.textContent = 'æ— æ³•è¯»å–ç›®å½•';
          treeMeta.textContent = 'ç¨åé‡è¯•';
        }
      }

      function startTreePolling() {
        stopTreePolling(false);
        treeOutput.textContent = 'åŠ è½½ä¸­...';
        treeMeta.textContent = 'åˆ·æ–°ä¸­';
        fetchTree();
        singleState.treeTimer = setInterval(fetchTree, 1500);
      }

      function stopTreePolling(clear = true) {
        if (singleState.treeTimer) {
          clearInterval(singleState.treeTimer);
          singleState.treeTimer = null;
        }
        if (clear) {
          treeOutput.textContent = 'æœªåŠ è½½';
          treeMeta.textContent = 'ç­‰å¾…ä»»åŠ¡';
        }
      }

      function stopSinglePolling() {
        if (singleState.pollTimer) {
          clearInterval(singleState.pollTimer);
          singleState.pollTimer = null;
        }
      }

      async function pollSingleStatus() {
        if (!singleState.jobId) return;
        try {
          const res = await fetch(`/api/jobs/${singleState.jobId}`);
          if (res.status === 404) {
            addLog('ä»»åŠ¡ä¸å­˜åœ¨ï¼Œåœæ­¢è½®è¯¢');
            stopSinglePolling();
            return;
          }
          if (!res.ok) throw new Error('poll failed');
          const job = await res.json();
          jobIdEl.textContent = job.id;
          jobTitle.textContent = job.title || '-';
          setStatus(job.status, job.message || job.status);
          setProgress(job.progress || 0);

          if (job.status === 'completed') {
            downloadLink.style.display = 'inline-flex';
            downloadLink.textContent = job.download_ready ? 'ä¸‹è½½ Zip' : 'æ‰“åŒ…å¹¶ä¸‹è½½';
            downloadLink.dataset.ready = job.download_ready ? 'true' : 'false';
            if (job.download_ready) {
              downloadLink.href = `/api/jobs/${job.id}/download`;
            }
            stopSinglePolling();
          }

          if (job.status === 'failed' && singleState.lastPolledStatus !== 'failed') {
            addLog(job.message ? `âŒ ${job.message}` : 'âŒ ä»»åŠ¡å¤±è´¥');
          }

          singleState.lastPolledStatus = job.status;
        } catch (err) {
          console.error('å•æœ¬è½®è¯¢å¤±è´¥', err);
        }
      }

      function startSinglePolling(reason = '') {
        stopSinglePolling();
        if (reason) addLog(reason);
        setWsIndicator('polling', 'å•æœ¬');
        pollSingleStatus();
        singleState.pollTimer = setInterval(pollSingleStatus, POLL_INTERVAL);
      }

      function handleSnapshot(payload) {
        if (payload.job) {
          jobIdEl.textContent = payload.job.id;
          jobTitle.textContent = payload.job.title || '-';
          setStatus(payload.job.status, payload.job.status);
          setProgress(payload.job.progress || 0);
        }
        (payload.events || []).forEach(evt => handleEvent(evt));
      }

      function handleEvent(evt) {
        if (!evt || !evt.type) return;
        switch (evt.type) {
          case 'status':
            setStatus('running', evt.message || '');
            addLog(evt.message || '');
            break;
          case 'progress':
            if (evt.value !== undefined) setProgress(evt.value);
            if (evt.message) addLog(evt.message);
            break;
          case 'log':
            addLog(evt.message);
            break;
          case 'error':
            setStatus('failed', evt.message || 'å‡ºé”™äº†');
            addLog('[é”™è¯¯] ' + (evt.message || ''));
            break;
          case 'packing':
            setStatus('running', evt.message || 'æ‰“åŒ…ä¸­...');
            addLog(evt.message || 'æ‰“åŒ…ä¸­...');
            break;
          case 'zip_ready':
            downloadLink.href = evt.download;
            downloadLink.style.display = 'inline-flex';
            downloadLink.textContent = 'ä¸‹è½½ Zip';
            downloadLink.dataset.ready = 'true';
            addLog('âœ… ' + (evt.message || 'æ‰“åŒ…å®Œæˆ'));
            break;
          case 'ready':
            setStatus('completed', evt.message || 'ä¸‹è½½å®Œæˆ');
            setProgress(1);
            // Show download button - will trigger prepare-download
            downloadLink.style.display = 'inline-flex';
            downloadLink.textContent = 'æ‰“åŒ…å¹¶ä¸‹è½½';
            downloadLink.dataset.ready = 'false';
            addLog('âœ… ä¸‹è½½å®Œæˆï¼Œç‚¹å‡»æŒ‰é’®æ‰“åŒ…');
            fetchTree().finally(() => stopTreePolling(false));
            break;
          case 'cancelled':
            setStatus('cancelled', evt.message || 'å·²å–æ¶ˆ');
            addLog(evt.message || 'å·²å–æ¶ˆ');
            stopTreePolling(false);
            break;
          case 'snapshot':
            handleSnapshot(evt);
            break;
        }
      }

      function openSocket(jobId) {
        if (!jobId) return;
        if (singleState.ws) {
          singleState.ws.close();
          singleState.ws = null;
        }
        if (singleState.reconnectTimer) {
          clearTimeout(singleState.reconnectTimer);
          singleState.reconnectTimer = null;
        }
        singleState.wsAttempts = 0;

        const connect = () => {
          if (!singleState.jobId) return;
          setWsIndicator('connecting', 'å•æœ¬');
          const proto = location.protocol === 'https:' ? 'wss' : 'ws';
          const ws = new WebSocket(`${proto}://${location.host}/ws/jobs/${jobId}`);
          singleState.ws = ws;
          let handled = false;

          ws.onopen = () => {
            handled = false;
            singleState.wsAttempts = 0;
            setWsIndicator('connected', 'å•æœ¬');
            stopSinglePolling();
          };

          ws.onmessage = (evt) => {
            try { handleEvent(JSON.parse(evt.data)); } catch (e) { console.error(e); }
          };

          const handleFailure = () => {
            if (handled) return;
            handled = true;
            if (singleState.reconnectTimer) {
              clearTimeout(singleState.reconnectTimer);
            }
            singleState.reconnectTimer = setTimeout(() => {
              if (!singleState.jobId) return;
              singleState.wsAttempts += 1;
              if (singleState.wsAttempts > WS_RETRY_LIMIT) {
                startSinglePolling('WebSocket å¤šæ¬¡å¤±è´¥ï¼Œåˆ‡æ¢ä¸ºè½®è¯¢');
                return;
              }
              setWsIndicator('reconnecting', 'å•æœ¬');
              connect();
            }, WS_RETRY_DELAY * Math.min(singleState.wsAttempts, 3));
          };

          ws.onclose = () => {
            addLog('WebSocket æ–­å¼€');
            handleFailure();
          };
          ws.onerror = handleFailure;
        };

        connect();
      }

      document.getElementById('job-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const albumId = e.target.album_id.value.trim();
        if (!albumId) return;
        $('start-btn').disabled = true;
        setStatus('running', 'åˆ›å»ºä»»åŠ¡');
        setProgress(0);
        logsEl.innerHTML = '';
        downloadLink.style.display = 'none';

        const res = await fetch('/api/jobs', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ album_id: albumId })
        });
        if (!res.ok) {
          addLog('åˆ›å»ºä»»åŠ¡å¤±è´¥');
          $('start-btn').disabled = false;
          return;
        }
        const data = await res.json();
        singleState.jobId = data.job_id;
        jobIdEl.textContent = data.job_id;
        setStatus('running', 'å‡†å¤‡ä¸‹è½½');
        openSocket(singleState.jobId);
        startTreePolling();
        $('start-btn').disabled = false;
      });

      // Download link - triggers prepare-download for lazy zip
      downloadLink.addEventListener('click', async (e) => {
        if (downloadLink.dataset.ready === 'true') {
          // Already zipped, proceed with download
          return;
        }
        e.preventDefault();
        if (!singleState.jobId) return;

        downloadLink.textContent = 'æ‰“åŒ…ä¸­...';
        downloadLink.style.pointerEvents = 'none';

        try {
          const res = await fetch(`/api/jobs/${singleState.jobId}/prepare-download`, { method: 'POST' });
          if (!res.ok) {
            const err = await res.json();
            addLog('æ‰“åŒ…å¤±è´¥: ' + (err.detail || 'æœªçŸ¥é”™è¯¯'));
            downloadLink.textContent = 'é‡è¯•æ‰“åŒ…';
            downloadLink.style.pointerEvents = 'auto';
            return;
          }
          const data = await res.json();
          downloadLink.href = data.download;
          downloadLink.dataset.ready = 'true';
          downloadLink.textContent = 'ä¸‹è½½ Zip';
          downloadLink.style.pointerEvents = 'auto';
          // Auto-click to download
          downloadLink.click();
        } catch (err) {
          addLog('æ‰“åŒ…è¯·æ±‚å¤±è´¥');
          downloadLink.textContent = 'é‡è¯•æ‰“åŒ…';
          downloadLink.style.pointerEvents = 'auto';
        }
      });

      deleteBtn.addEventListener('click', async () => {
        if (!singleState.jobId) return;
        await fetch(`/api/jobs/${singleState.jobId}`, { method: 'DELETE' });
        addLog('å·²åˆ é™¤æœåŠ¡å™¨æ–‡ä»¶');
        resetSingleUI();
      });

      function resetSingleUI() {
        singleState.jobId = null;
        if (singleState.ws) {
          singleState.ws.close();
          singleState.ws = null;
        }
        if (singleState.reconnectTimer) {
          clearTimeout(singleState.reconnectTimer);
          singleState.reconnectTimer = null;
        }
        stopSinglePolling();
        jobStatus.textContent = 'å¾…å¼€å§‹';
        jobIdEl.textContent = '-';
        jobTitle.textContent = '-';
        statusDot.className = 'status-dot';
        bar.style.width = '0%';
        progressText.textContent = '0%';
        downloadLink.style.display = 'none';
        downloadLink.dataset.ready = 'false';
        stopTreePolling();
        treeOutput.textContent = 'ç›®å½•å·²åˆ é™¤';
        treeMeta.textContent = '';
        setWsIndicator('offline');
      }

      // ==== Batch Download ====
      const batchState = {
        jobId: null,
        ws: null,
        albums: [],
        treeTimer: null,
        wsAttempts: 0,
        reconnectTimer: null,
        pollTimer: null
      };
      const albumListEl = $('album-list');
      const batchStats = $('batch-stats');
      const batchStatus = $('batch-status');
      const batchCompleted = $('batch-completed');
      const batchTotal = $('batch-total');
      const batchBar = $('batch-bar');
      const batchProgressText = $('batch-progress-text');
      const batchProgressContainer = $('batch-progress-container');
      const batchDownloadLink = $('batch-download-link');
      const batchCancelBtn = $('batch-cancel-btn');
      const batchDeleteBtn = $('batch-delete-btn');

      // Batch tree polling functions
      async function fetchBatchTree() {
        if (!batchState.jobId) return;
        try {
          const res = await fetch(`/api/batch-jobs/${batchState.jobId}/tree`);
          if (res.status === 404) {
            treeOutput.textContent = 'ç›®å½•å·²æ¸…ç†';
            treeMeta.textContent = 'ä»»åŠ¡ä¸å­˜åœ¨æˆ–å·²åˆ é™¤';
            stopBatchTreePolling(false);
            return;
          }
          if (!res.ok) throw new Error('failed');
          const data = await res.json();
          renderTree(data.tree, data.root, data.generated_at);
        } catch (err) {
          treeOutput.textContent = 'æ— æ³•è¯»å–ç›®å½•';
          treeMeta.textContent = 'ç¨åé‡è¯•';
        }
      }

      function startBatchTreePolling() {
        stopBatchTreePolling(false);
        treeOutput.textContent = 'åŠ è½½ä¸­...';
        treeMeta.textContent = 'åˆ·æ–°ä¸­';
        fetchBatchTree();
        batchState.treeTimer = setInterval(fetchBatchTree, 1500);
      }

      function stopBatchTreePolling(clear = true) {
        if (batchState.treeTimer) {
          clearInterval(batchState.treeTimer);
          batchState.treeTimer = null;
        }
        if (clear) {
          treeOutput.textContent = 'æœªåŠ è½½';
          treeMeta.textContent = 'ç­‰å¾…ä»»åŠ¡';
        }
      }

      function stopBatchPolling() {
        if (batchState.pollTimer) {
          clearInterval(batchState.pollTimer);
          batchState.pollTimer = null;
        }
      }

      async function pollBatchStatus() {
        if (!batchState.jobId) return;
        try {
          const res = await fetch(`/api/batch-jobs/${batchState.jobId}`);
          if (res.status === 404) {
            addLog('æ‰¹é‡ä»»åŠ¡ä¸å­˜åœ¨ï¼Œåœæ­¢è½®è¯¢');
            stopBatchPolling();
            return;
          }
          if (!res.ok) throw new Error('poll failed');
          const job = await res.json();
          updateBatchUI(job);
          if (job.albums) renderAlbumList(job.albums);

          if (job.status === 'completed' || job.status === 'cancelled') {
            batchDownloadLink.style.display = 'inline-flex';
            batchDownloadLink.textContent = job.download_ready ? 'ä¸‹è½½ Zip' : 'æ‰“åŒ…å¹¶ä¸‹è½½';
            batchDownloadLink.dataset.ready = job.download_ready ? 'true' : 'false';
            if (job.download_ready) {
              batchDownloadLink.href = `/api/batch-jobs/${job.id}/download`;
            }
            batchCancelBtn.style.display = 'none';
            batchDeleteBtn.style.display = 'inline-flex';
            stopBatchPolling();
          }
        } catch (err) {
          console.error('æ‰¹é‡è½®è¯¢å¤±è´¥', err);
        }
      }

      function startBatchPolling(reason = '') {
        stopBatchPolling();
        if (reason) addLog(reason);
        setWsIndicator('polling', 'æ‰¹é‡');
        pollBatchStatus();
        batchState.pollTimer = setInterval(pollBatchStatus, POLL_INTERVAL);
      }

      // Load saved credentials from localStorage
      try {
        const savedUsername = localStorage.getItem('jm_username');
        const savedPassword = localStorage.getItem('jm_password');
        const batchForm = document.getElementById('batch-form');
        if (savedUsername) batchForm.username.value = savedUsername;
        if (savedPassword) batchForm.password.value = savedPassword;
      } catch (err) {
        console.warn('Failed to load credentials from localStorage:', err);
      }

      function updateBatchUI(job) {
        if (!job) return;
        batchStatus.textContent = job.status === 'completed' ? 'å®Œæˆ' :
          job.status === 'failed' ? 'å¤±è´¥' :
            job.status === 'cancelled' ? 'å·²å–æ¶ˆ' : 'ä¸‹è½½ä¸­';
        batchCompleted.textContent = job.completed_albums || 0;
        batchTotal.textContent = job.total_albums || 0;

        const pct = Math.max(0, Math.min(1, job.progress || 0));
        batchBar.style.width = `${(pct * 100).toFixed(1)}%`;
        batchProgressText.textContent = `${(pct * 100).toFixed(1)}%`;
      }

      function renderAlbumList(albums) {
        albumListEl.innerHTML = '';
        batchState.albums = albums || [];

        albums.forEach((album, idx) => {
          const li = document.createElement('li');
          li.className = 'album-item ' + album.status;
          li.id = `album-${idx}`;

          const icon = album.status === 'completed' ? 'âœ…' :
            album.status === 'partial' ? 'âš ï¸' :
              album.status === 'failed' ? 'âŒ' :
                album.status === 'downloading' ? 'â¬‡ï¸' : 'â³';

          const retryBtn = album.status === 'failed'
            ? `<button class="retry-btn" onclick="retryAlbum('${album.album_id}', ${idx})">ğŸ”„ é‡è¯•</button>`
            : '';

          const retryInfo = album.retry_count > 0 ? ` (å·²é‡è¯•${album.retry_count}æ¬¡)` : '';
          const partialInfo = album.status === 'partial' && album.failed_images
            ? ` (${album.failed_images}å¼ å¤±è´¥)`
            : '';

          li.innerHTML = `
        <div class="album-icon">${icon}</div>
        <div class="album-info">
          <div class="album-title">${album.title}</div>
          <div class="album-id">ID: ${album.album_id}${retryInfo}${partialInfo}</div>
          ${album.error_message ? `<div class="album-error">${album.error_message}</div>` : ''}
        </div>
        ${album.status === 'downloading' ? `
          <div class="mini-bar">
            <div class="mini-bar-fill" style="width: ${(album.progress * 100).toFixed(1)}%"></div>
          </div>
        ` : album.status === 'failed' ? retryBtn : `
          <div class="album-progress">${album.status === 'completed' ? '100%' : album.status === 'partial' ? 'éƒ¨åˆ†' : 'ç­‰å¾…'}</div>
        `}
      `;
          albumListEl.appendChild(li);
        });
      }

      // Global function for retry button onclick
      window.retryAlbum = async function (albumId, index) {
        if (!batchState.jobId) return;

        const btn = document.querySelector(`#album-${index} .retry-btn`);
        if (btn) {
          btn.disabled = true;
          btn.textContent = 'é‡è¯•ä¸­...';
        }

        try {
          const res = await fetch(`/api/batch-jobs/${batchState.jobId}/albums/${albumId}/retry`, {
            method: 'POST'
          });
          const data = await res.json();
          if (data.status === 'success') {
            addLog(`âœ… æ‰‹åŠ¨é‡è¯•æˆåŠŸ: ${data.album?.title || albumId}`);
          } else {
            addLog(`âŒ æ‰‹åŠ¨é‡è¯•å¤±è´¥: ${data.error || 'æœªçŸ¥é”™è¯¯'}`);
          }
        } catch (err) {
          addLog(`âŒ é‡è¯•è¯·æ±‚å¤±è´¥: ${err.message}`);
          if (btn) {
            btn.disabled = false;
            btn.textContent = 'ğŸ”„ é‡è¯•';
          }
        }
      };

      function updateAlbumItem(index, album) {
        if (!batchState.albums[index]) return;
        batchState.albums[index] = { ...batchState.albums[index], ...album };
        renderAlbumList(batchState.albums);
      }

      function handleBatchEvent(evt) {
        if (!evt || !evt.type) return;
        addLog(evt.message || evt.type);

        switch (evt.type) {
          case 'status':
            batchStatus.textContent = evt.message || 'å¤„ç†ä¸­';
            break;
          case 'albums_list':
            renderAlbumList(evt.albums || []);
            batchTotal.textContent = (evt.albums || []).length;
            batchStats.style.display = 'flex';
            batchProgressContainer.style.display = 'block';
            batchProgressText.style.display = 'block';
            batchCancelBtn.style.display = 'inline-flex';
            break;
          case 'album_start':
            if (evt.album) updateAlbumItem(evt.index, evt.album);
            break;
          case 'album_progress':
            if (batchState.albums[evt.index]) {
              batchState.albums[evt.index].progress = evt.progress;
              renderAlbumList(batchState.albums);
            }
            break;
          case 'album_completed':
            if (evt.album) updateAlbumItem(evt.index, evt.album);
            if (evt.job) updateBatchUI(evt.job);
            break;
          case 'album_partial':
            if (evt.album) updateAlbumItem(evt.index, evt.album);
            if (evt.job) updateBatchUI(evt.job);
            addLog(`âš ï¸ éƒ¨åˆ†å®Œæˆ: ${evt.album?.title} (${evt.failed_count}/${evt.total_count} å›¾ç‰‡å¤±è´¥)`);
            break;
          case 'album_failed':
            if (evt.album) updateAlbumItem(evt.index, evt.album);
            break;
          case 'retry_phase':
            batchStatus.textContent = evt.message || 'æ­£åœ¨é‡è¯•å¤±è´¥ä»»åŠ¡...';
            break;
          case 'retry_start':
            if (evt.album) updateAlbumItem(evt.index, evt.album);
            batchStatus.textContent = evt.message || 'é‡è¯•ä¸­...';
            break;
          case 'retry_completed':
            if (evt.album) updateAlbumItem(evt.index, evt.album);
            break;
          case 'retry_failed':
            if (evt.album) updateAlbumItem(evt.index, evt.album);
            break;
          case 'failed_summary':
            // Log all failed albums
            (evt.failed_albums || []).forEach(a => {
              addLog(`âŒ æœ€ç»ˆå¤±è´¥: ${a.title} (ID: ${a.album_id})`);
            });
            break;
          case 'manual_retry_start':
            if (evt.album) updateAlbumItem(evt.index, evt.album);
            batchStatus.textContent = evt.message || 'æ‰‹åŠ¨é‡è¯•ä¸­...';
            break;
          case 'manual_retry_completed':
            if (evt.album) updateAlbumItem(evt.index, evt.album);
            batchStatus.textContent = 'å®Œæˆ';
            break;
          case 'manual_retry_failed':
            if (evt.album) updateAlbumItem(evt.index, evt.album);
            break;
          case 'packing':
            batchStatus.textContent = 'æ‰“åŒ…ä¸­...';
            break;
          case 'empty':
            batchStatus.textContent = 'æ”¶è—å¤¹ä¸ºç©º';
            batchCancelBtn.style.display = 'none';
            break;
          case 'error':
            batchStatus.textContent = 'é”™è¯¯: ' + (evt.message || '');
            batchCancelBtn.style.display = 'none';
            break;
          case 'cancelled':
            batchStatus.textContent = evt.message || 'å·²å–æ¶ˆ';
            batchCancelBtn.style.display = 'none';
            batchDeleteBtn.style.display = 'inline-flex';
            // Show download for partial results (lazy zip)
            if (evt.completed_count > 0) {
              batchDownloadLink.textContent = `æ‰“åŒ…å¹¶ä¸‹è½½ (${evt.completed_count}/${evt.total_count})`;
              batchDownloadLink.style.display = 'inline-flex';
              batchDownloadLink.dataset.ready = 'false';
            }
            stopBatchTreePolling(false);
            break;
          case 'zip_ready':
            batchDownloadLink.href = evt.download;
            batchDownloadLink.textContent = 'ä¸‹è½½ Zip';
            batchDownloadLink.style.display = 'inline-flex';
            batchDownloadLink.dataset.ready = 'true';
            break;
          case 'ready':
            batchStatus.textContent = evt.message || 'ä¸‹è½½å®Œæˆ';
            batchProgressText.textContent = '100%';
            batchBar.style.width = '100%';
            // Lazy zip - show button but not zipped yet
            batchDownloadLink.textContent = 'æ‰“åŒ…å¹¶ä¸‹è½½';
            batchDownloadLink.style.display = 'inline-flex';
            batchDownloadLink.dataset.ready = 'false';
            batchCancelBtn.style.display = 'none';
            batchDeleteBtn.style.display = 'inline-flex';
            stopBatchTreePolling(false);
            break;
          case 'snapshot':
            if (evt.job) {
              updateBatchUI(evt.job);
              if (evt.job.albums) renderAlbumList(evt.job.albums);
            }
            (evt.events || []).forEach(e => handleBatchEvent(e));
            break;
        }
      }

      function openBatchSocket(jobId) {
        if (!jobId) return;
        if (batchState.ws) {
          batchState.ws.close();
          batchState.ws = null;
        }
        if (batchState.reconnectTimer) {
          clearTimeout(batchState.reconnectTimer);
          batchState.reconnectTimer = null;
        }
        batchState.wsAttempts = 0;

        const connect = () => {
          if (!batchState.jobId) return;
          setWsIndicator('connecting', 'æ‰¹é‡');
          const proto = location.protocol === 'https:' ? 'wss' : 'ws';
          const ws = new WebSocket(`${proto}://${location.host}/ws/batch-jobs/${jobId}`);
          batchState.ws = ws;
          let handled = false;

          ws.onopen = () => {
            handled = false;
            batchState.wsAttempts = 0;
            setWsIndicator('connected', 'æ‰¹é‡');
            stopBatchPolling();
          };

          ws.onmessage = (evt) => {
            try { handleBatchEvent(JSON.parse(evt.data)); } catch (e) { console.error(e); }
          };

          const handleFailure = () => {
            if (handled) return;
            handled = true;
            if (batchState.reconnectTimer) {
              clearTimeout(batchState.reconnectTimer);
            }
            batchState.reconnectTimer = setTimeout(() => {
              if (!batchState.jobId) return;
              batchState.wsAttempts += 1;
              if (batchState.wsAttempts > WS_RETRY_LIMIT) {
                startBatchPolling('æ‰¹é‡ WebSocket å¤šæ¬¡å¤±è´¥ï¼Œåˆ‡æ¢ä¸ºè½®è¯¢');
                return;
              }
              setWsIndicator('reconnecting', 'æ‰¹é‡');
              connect();
            }, WS_RETRY_DELAY * Math.min(batchState.wsAttempts, 3));
          };

          ws.onclose = () => {
            addLog('æ‰¹é‡ä¸‹è½½ WebSocket æ–­å¼€');
            handleFailure();
          };
          ws.onerror = handleFailure;
        };

        connect();
      }

      document.getElementById('batch-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const username = e.target.username.value.trim();
        const password = e.target.password.value.trim();
        if (!username || !password) return;

        // Save credentials to localStorage
        try {
          localStorage.setItem('jm_username', username);
          localStorage.setItem('jm_password', password);
        } catch (err) {
          console.warn('Failed to save credentials to localStorage:', err);
        }

        $('batch-start-btn').disabled = true;
        logsEl.innerHTML = '';
        albumListEl.innerHTML = '';
        batchDownloadLink.style.display = 'none';
        batchDeleteBtn.style.display = 'none';
        batchStats.style.display = 'none';
        batchProgressContainer.style.display = 'none';
        batchProgressText.style.display = 'none';
        batchBar.style.width = '0%';

        addLog('æ­£åœ¨ç™»å½•å¹¶è·å–æ”¶è—å¤¹...');

        const res = await fetch('/api/batch-jobs', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, password })
        });

        if (!res.ok) {
          addLog('åˆ›å»ºæ‰¹é‡ä»»åŠ¡å¤±è´¥');
          $('batch-start-btn').disabled = false;
          return;
        }

        const data = await res.json();
        batchState.jobId = data.job_id;
        batchStats.style.display = 'flex';
        batchStatus.textContent = 'è¿æ¥ä¸­...';

        openBatchSocket(batchState.jobId);
        startBatchTreePolling();  // Start tree polling for batch downloads
        $('batch-start-btn').disabled = false;
      });

      batchCancelBtn.addEventListener('click', async () => {
        if (!batchState.jobId) return;
        await fetch(`/api/batch-jobs/${batchState.jobId}/cancel`, { method: 'POST' });
        addLog('å·²å‘é€å–æ¶ˆè¯·æ±‚');
      });

      batchDeleteBtn.addEventListener('click', async () => {
        if (!batchState.jobId) return;
        await fetch(`/api/batch-jobs/${batchState.jobId}`, { method: 'DELETE' });
        addLog('å·²åˆ é™¤æœåŠ¡å™¨æ–‡ä»¶');
        resetBatchUI();
      });

      // Batch download link - triggers prepare-download for lazy zip
      batchDownloadLink.addEventListener('click', async (e) => {
        if (batchDownloadLink.dataset.ready === 'true') {
          return; // Already zipped
        }
        e.preventDefault();
        if (!batchState.jobId) return;

        batchDownloadLink.textContent = 'æ‰“åŒ…ä¸­...';
        batchDownloadLink.style.pointerEvents = 'none';

        try {
          const res = await fetch(`/api/batch-jobs/${batchState.jobId}/prepare-download`, { method: 'POST' });
          if (!res.ok) {
            const err = await res.json();
            addLog('æ‰“åŒ…å¤±è´¥: ' + (err.detail || 'æœªçŸ¥é”™è¯¯'));
            batchDownloadLink.textContent = 'é‡è¯•æ‰“åŒ…';
            batchDownloadLink.style.pointerEvents = 'auto';
            return;
          }
          const data = await res.json();
          batchDownloadLink.href = data.download;
          batchDownloadLink.dataset.ready = 'true';
          batchDownloadLink.textContent = 'ä¸‹è½½ Zip';
          batchDownloadLink.style.pointerEvents = 'auto';
          batchDownloadLink.click();
        } catch (err) {
          addLog('æ‰“åŒ…è¯·æ±‚å¤±è´¥');
          batchDownloadLink.textContent = 'é‡è¯•æ‰“åŒ…';
          batchDownloadLink.style.pointerEvents = 'auto';
        }
      });

      function resetBatchUI() {
        batchState.jobId = null;
        if (batchState.ws) {
          batchState.ws.close();
          batchState.ws = null;
        }
        if (batchState.reconnectTimer) {
          clearTimeout(batchState.reconnectTimer);
          batchState.reconnectTimer = null;
        }
        stopBatchPolling();
        batchStatus.textContent = 'å‡†å¤‡ä¸­';
        batchCompleted.textContent = '0';
        batchTotal.textContent = '0';
        batchBar.style.width = '0%';
        batchProgressText.textContent = '0%';
        batchStats.style.display = 'none';
        batchProgressContainer.style.display = 'none';
        batchProgressText.style.display = 'none';
        batchDownloadLink.style.display = 'none';
        batchDownloadLink.dataset.ready = 'false';
        batchDeleteBtn.style.display = 'none';
        batchCancelBtn.style.display = 'none';
        albumListEl.innerHTML = '';
        stopBatchTreePolling();
        treeOutput.textContent = 'ç›®å½•å·²åˆ é™¤';
        treeMeta.textContent = '';
        if (!singleState.jobId) {
          setWsIndicator('offline');
        }
      }

      // ==== Cleanup Button ====
      $('cleanup-btn').addEventListener('click', async () => {
        addLog('æ­£åœ¨æ¸…ç†æ‰€æœ‰æ•°æ®...');
        try {
          await fetch('/api/cleanup', { method: 'DELETE' });
          addLog('âœ… æ‰€æœ‰æ•°æ®å·²æ¸…ç†');
          resetSingleUI();
          resetBatchUI();
          logsEl.innerHTML = '';
          addLog('ç³»ç»Ÿå·²é‡ç½®');
        } catch (err) {
          addLog('æ¸…ç†å¤±è´¥: ' + err.message);
        }
      });

      // ==== State Restoration on Page Load ====
      async function restoreState() {
        // Try to restore single job
        try {
          const res = await fetch('/api/current-job');
          const data = await res.json();
          if (data.job) {
            singleState.jobId = data.job.id;
            jobIdEl.textContent = data.job.id;
            jobTitle.textContent = data.job.title || '-';
            setProgress(data.job.progress || 0);
            setStatus(data.job.status, data.job.message || data.job.status);
            if (data.job.status === 'completed') {
              downloadLink.style.display = 'inline-flex';
              downloadLink.textContent = data.job.zip_path ? 'ä¸‹è½½ Zip' : 'æ‰“åŒ…å¹¶ä¸‹è½½';
              downloadLink.dataset.ready = data.job.zip_path ? 'true' : 'false';
              if (data.job.zip_path) {
                downloadLink.href = `/api/jobs/${data.job.id}/download`;
              }
            }
            if (data.job.status === 'running') {
              openSocket(data.job.id);
              startTreePolling();
            } else {
              fetchTree();
            }
            addLog('[æ¢å¤] å‘ç°ä¸Šæ¬¡çš„å•æœ¬ä»»åŠ¡');
          }
        } catch (err) {
          console.error('Failed to restore single job:', err);
        }

        // Try to restore batch job
        try {
          const res = await fetch('/api/current-batch-job');
          const data = await res.json();
          if (data.job) {
            batchState.jobId = data.job.id;
            batchState.albums = data.albums || [];
            batchStats.style.display = 'flex';
            batchStatus.textContent = data.job.status === 'running' ? 'è¿è¡Œä¸­' : data.job.message || data.job.status;
            batchTotal.textContent = (data.albums || []).length;
            const completedCount = (data.albums || []).filter(a => a.status === 'completed').length;
            batchCompleted.textContent = completedCount;
            batchProgressContainer.style.display = 'block';
            batchProgressText.style.display = 'block';
            const pct = data.job.progress || 0;
            batchBar.style.width = `${(pct * 100).toFixed(1)}%`;
            batchProgressText.textContent = `${(pct * 100).toFixed(1)}%`;
            renderAlbumList(data.albums || []);

            if (data.job.status === 'completed' || data.job.status === 'cancelled') {
              batchDownloadLink.style.display = 'inline-flex';
              batchDownloadLink.textContent = data.job.zip_path ? 'ä¸‹è½½ Zip' : 'æ‰“åŒ…å¹¶ä¸‹è½½';
              batchDownloadLink.dataset.ready = data.job.zip_path ? 'true' : 'false';
              if (data.job.zip_path) {
                batchDownloadLink.href = `/api/batch-jobs/${data.job.id}/download`;
              }
              batchDeleteBtn.style.display = 'inline-flex';
            }
            if (data.job.status === 'running') {
              openBatchSocket(data.job.id);
              startBatchTreePolling();
              batchCancelBtn.style.display = 'inline-flex';
            } else {
              fetchBatchTree();
            }
            addLog('[æ¢å¤] å‘ç°ä¸Šæ¬¡çš„æ‰¹é‡ä»»åŠ¡');
            // Switch to batch tab
            document.querySelector('.tab[data-tab="batch"]').click();
          }
        } catch (err) {
          console.error('Failed to restore batch job:', err);
        }
      }

      // Restore state when page loads
      restoreState();
    })();
  </script>
</body>

</html>                batchDownloadLink.href = `/api/batch-jobs/${data.job.id}/download`;
              }
              batchDeleteBtn.style.display = 'inline-flex';
            }
            if (data.job.status === 'running') {
              openBatchSocket(data.job.id);
              startBatchTreePolling();
              batchCancelBtn.style.display = 'inline-flex';
            } else {
              fetchBatchTree();
            }
            addLog('[æ¢å¤] å‘ç°ä¸Šæ¬¡çš„æ‰¹é‡ä»»åŠ¡');
            // Switch to batch tab
            document.querySelector('.tab[data-tab="batch"]').click();
          }
        } catch (err) {
          console.error('Failed to restore batch job:', err);
        }
      }

      // Restore state when page loads
      restoreState();
    })();
  </script>
</body>

</html>